<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    
    <style>
        body { background-color: #1a1917; color: #fff; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
        .goban-container { background-color: #dbb06d; position: relative; box-shadow: 0 20px 50px rgba(0,0,0,0.8); border: 2px solid #8b4513; }
        .line-v, .line-h { position: absolute; background-color: rgba(0,0,0,0.7); }
        .hoshi { position: absolute; background-color: #000; border-radius: 50%; transform: translate(-50%, -50%); z-index: 5; }
        .stone { position: absolute; border-radius: 50%; transform: translate(-50%, -50%); z-index: 10; transition: transform 0.1s ease-out; }
        .stone-black { background: radial-gradient(circle at 30% 30%, #444, #000); box-shadow: 2px 3px 5px rgba(0,0,0,0.5); }
        .stone-white { background: radial-gradient(circle at 30% 30%, #fff, #bbb); box-shadow: 2px 3px 5px rgba(0,0,0,0.4); }
        .marker { position: absolute; width: 35%; height: 35%; border: 2px solid #ff4b4b; border-radius: 50%; top: 32.5%; left: 32.5%; }
        
        .territory-marker { position: absolute; transform: translate(-50%, -50%); width: 3%; height: 3%; z-index: 6; opacity: 0.85; border-radius: 2px; }
        .territory-marker-black { background-color: #000; box-shadow: 0 1px 2px rgba(0,0,0,0.3); }
        .territory-marker-white { background-color: #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2); border: 1px solid rgba(0,0,0,0.15); }
        
        .click-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 20; display: grid; }
        
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
        .ko-warning { animation: shake 0.3s ease-in-out; }
        
        .pulse { animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useMemo, useEffect, useRef } = React;

        const firebaseConfig = {
            apiKey: "AIzaSyAeQmAqBS5Qr_qFlgWVLskVdCM7ZpK1Po0",
            authDomain: "gomaster-online.firebaseapp.com",
            databaseURL: "https://gomaster-online-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "gomaster-online",
            storageBucket: "gomaster-online.firebasestorage.app",
            messagingSenderId: "141900806830",
            appId: "1:141900806830:web:dfc36705f535314745cb3f"
        };

        let firebaseApp, database;
        try {
            firebaseApp = firebase.initializeApp(firebaseConfig);
            database = firebase.database();
        } catch (error) { console.log("Firebase not configured:", error); }

        const createEmptyBoard = (size) => Array(size).fill(null).map(() => Array(size).fill(null));

        const boardToFirebase = (board) => {
            if (!board) return null;
            const obj = {};
            board.forEach((row, i) => {
                row.forEach((cell, j) => {
                    if (cell !== null) obj[`x${i}y${j}`] = cell;
                });
            });
            return Object.keys(obj).length > 0 ? obj : null;
        };

        const firebaseToBoard = (firebaseObj, size) => {
            const board = createEmptyBoard(size);
            if (!firebaseObj) return board;
            Object.keys(firebaseObj).forEach(key => {
                const match = key.match(/x(\d+)y(\d+)/);
                if (match) {
                    const i = parseInt(match[1]), j = parseInt(match[2]);
                    if (i < size && j < size) board[i][j] = firebaseObj[key];
                }
            });
            return board;
        };

        const GoApp = () => {
            const [size, setSize] = useState(19);
            const [board, setBoard] = useState(createEmptyBoard(19));
            const [previousBoard, setPreviousBoard] = useState(null);
            const [turn, setTurn] = useState('B');
            const [captures, setCaptures] = useState({ B: 0, W: 0 });
            const [lastMove, setLastMove] = useState(null);
            const [passCount, setPassCount] = useState(0);
            const [gameOver, setGameOver] = useState(false);
            const [scoreInfo, setScoreInfo] = useState(null);
            const [territoryMap, setTerritoryMap] = useState(null);
            const [koWarning, setKoWarning] = useState(false);

            const [gameMode, setGameMode] = useState('menu');
            const [roomId, setRoomId] = useState('');
            const [inputRoomId, setInputRoomId] = useState('');
            const [playerColor, setPlayerColor] = useState(null);
            const [isConnected, setIsConnected] = useState(false);
            const [opponentConnected, setOpponentConnected] = useState(false);
            const gameRef = useRef(null);
            
            // IA: Nouveaux √©tats pour le mode IA
            const [aiDifficulty, setAiDifficulty] = useState('medium');
            const [isAiThinking, setIsAiThinking] = useState(false);

            const KOMI = 6.5;
            const cellSize = 100 / (size + 1);

            const generateRoomId = () => Math.random().toString(36).substring(2, 8).toUpperCase();

            // IA: Logique pour d√©marrer une partie contre l'IA
            const startAiGame = () => {
                resetGame(size, 'ai');
            };

            const createOnlineGame = () => {
                if (!database) { alert('Firebase n\'est pas configur√©!'); return; }
                const newRoomId = generateRoomId();
                const initialBoard = createEmptyBoard(size);
                
                setRoomId(newRoomId);
                setPlayerColor('B');
                setGameMode('online');
                setIsConnected(true);
                setBoard(initialBoard);
                setTurn('B');
                setCaptures({ B: 0, W: 0 });
                setLastMove(null);
                setPassCount(0);
                setPreviousBoard(null);

                gameRef.current = database.ref('games/' + newRoomId);
                gameRef.current.set({
                    board: boardToFirebase(initialBoard), previousBoard: null, turn: 'B',
                    captures: { B: 0, W: 0 }, lastMove: null, passCount: 0, size: size,
                    gameOver: false, scoreInfo: null, territoryMap: null,
                    players: { black: true, white: false }, createdAt: Date.now()
                });

                gameRef.current.child('players/white').on('value', (snapshot) => setOpponentConnected(snapshot.val() === true));
                listenToGameUpdates(newRoomId);
            };

            const joinOnlineGame = (roomIdToJoin) => {
                if (!database) { alert('Firebase n\'est pas configur√©!'); return; }
                if (!roomIdToJoin) { alert('Veuillez entrer un code de partie!'); return; }

                gameRef.current = database.ref('games/' + roomIdToJoin);
                gameRef.current.once('value', (snapshot) => {
                    if (snapshot.exists()) {
                        const gameData = snapshot.val();
                        if (!gameData.players.white) {
                            setRoomId(roomIdToJoin); setPlayerColor('W'); setGameMode('online');
                            setIsConnected(true); setOpponentConnected(true);
                            gameRef.current.child('players/white').set(true);
                            
                            const boardSize = gameData.size || 19;
                            setSize(boardSize);
                            setBoard(firebaseToBoard(gameData.board, boardSize));
                            setPreviousBoard(gameData.previousBoard ? firebaseToBoard(gameData.previousBoard, boardSize) : null);
                            setTurn(gameData.turn || 'B'); setCaptures(gameData.captures || { B: 0, W: 0 });
                            setLastMove(gameData.lastMove || null); setPassCount(gameData.passCount || 0);
                            setGameOver(gameData.gameOver || false); setScoreInfo(gameData.scoreInfo || null);
                            setTerritoryMap(gameData.territoryMap ? firebaseToBoard(gameData.territoryMap, boardSize) : null);

                            listenToGameUpdates(roomIdToJoin);
                        } else { alert('Cette partie est d√©j√† compl√®te!'); }
                    } else { alert('Partie introuvable! V√©rifiez le code.'); }
                });
            };

            const listenToGameUpdates = (roomIdToListen) => {
                const ref = database.ref('games/' + roomIdToListen);
                ref.on('value', (snapshot) => {
                    if (snapshot.exists()) {
                        const gameData = snapshot.val();
                        if (gameData.board !== undefined) {
                            const boardSize = gameData.size || 19;
                            setBoard(firebaseToBoard(gameData.board, boardSize));
                            setPreviousBoard(gameData.previousBoard ? firebaseToBoard(gameData.previousBoard, boardSize) : null);
                            setTurn(gameData.turn || 'B'); setCaptures(gameData.captures || { B: 0, W: 0 });
                            setLastMove(gameData.lastMove || null); setPassCount(gameData.passCount || 0);
                            setGameOver(gameData.gameOver || false); setScoreInfo(gameData.scoreInfo || null);
                            setTerritoryMap(gameData.territoryMap ? firebaseToBoard(gameData.territoryMap, boardSize) : null);
                        }
                    }
                });
            };

            const updateGameState = (newBoard, newPreviousBoard, newTurn, newCaptures, newLastMove, newPassCount) => {
                if (gameRef.current) {
                    gameRef.current.update({
                        board: boardToFirebase(newBoard), previousBoard: boardToFirebase(newPreviousBoard),
                        turn: newTurn, captures: newCaptures, lastMove: newLastMove, passCount: newPassCount
                    });
                }
            };

            const endGameOnline = (winner, finalB, finalW, territoryMapData = null) => {
                if (gameRef.current) {
                    gameRef.current.update({
                        gameOver: true,
                        scoreInfo: { winner, finalB, finalW },
                        territoryMap: territoryMapData ? boardToFirebase(territoryMapData) : null
                    });
                }
            };

            useEffect(() => {
                return () => { if (gameRef.current) gameRef.current.off(); };
            }, []);

            const boardsAreEqual = (b1, b2) => b1 && b2 && b1.length === b2.length && b1.every((row, i) => row.every((cell, j) => cell === b2[i][j]));

            const resetGame = (newSize, newGameMode = 'menu') => {
                const boardSize = newSize || size;
                setSize(boardSize);
                setBoard(createEmptyBoard(boardSize));
                setPreviousBoard(null);
                setTurn('B');
                setCaptures({ B: 0, W: 0 });
                setLastMove(null);
                setPassCount(0);
                setGameOver(false);
                setScoreInfo(null);
                setTerritoryMap(null);
                setKoWarning(false);
                setIsAiThinking(false);
                
                if (newGameMode === 'menu') {
                    if (gameRef.current) {
                        gameRef.current.off();
                        gameRef.current = null;
                    }
                    setGameMode('menu');
                    setRoomId('');
                    setInputRoomId('');
                    setPlayerColor(null);
                    setIsConnected(false);
                    setOpponentConnected(false);
                } else {
                    setGameMode(newGameMode);
                }
            };

            const getGroup = (x, y, color, currentBoard) => {
                const group = new Set();
                const liberties = new Set();
                const stack = [[x, y]];
                const key = (i, j) => `${i},${j}`;
                group.add(key(x, y));

                while (stack.length > 0) {
                    const [cx, cy] = stack.pop();
                    [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
                        const nx = cx + dx, ny = cy + dy;
                        if (nx >= 0 && nx < size && ny >= 0 && ny < size) {
                            if (currentBoard[nx][ny] === null) {
                                liberties.add(key(nx, ny));
                            } else if (currentBoard[nx][ny] === color && !group.has(key(nx, ny))) {
                                group.add(key(nx, ny));
                                stack.push([nx, ny]);
                            }
                        }
                    });
                }
                return { group, libertiesCount: liberties.size, groupCoords: Array.from(group).map(k => k.split(',').map(Number)) };
            };

            // IA: Moteur de d√©cision principal de l'IA
            const findBestMoveForAI = () => {
                const opponent = 'B';
                const aiColor = 'W';
                let possibleMoves = [];

                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size; j++) {
                        if (board[i][j] === null) {
                            possibleMoves.push({ x: i, y: j, score: 0 });
                        }
                    }
                }

                if (possibleMoves.length === 0) return null;

                // IA: √âvaluation de chaque coup possible
                possibleMoves.forEach(move => {
                    let tempBoard = board.map(row => [...row]);
                    tempBoard[move.x][move.y] = aiColor;
                    let capturedStones = 0;
                    let isSuicide = false;

                    // Offensive: Check for captures
                    [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
                        const nx = move.x + dx, ny = move.y + dy;
                        if (nx >= 0 && nx < size && ny >= 0 && ny < size && tempBoard[nx][ny] === opponent) {
                            const { group, libertiesCount } = getGroup(nx, ny, opponent, tempBoard);
                            if (libertiesCount === 0) {
                                move.score += 100 * group.size; // Priorit√© √† la capture
                                capturedStones += group.size;
                            }
                        }
                    });
                    
                    if (capturedStones > 0) {
                       const boardAfterCapture = tempBoard.map(r => [...r]);
                        for(let i=0; i<size; i++) {
                            for(let j=0; j<size; j++) {
                                if(boardAfterCapture[i][j] === opponent && getGroup(i, j, opponent, boardAfterCapture).libertiesCount === 0) {
                                    boardAfterCapture[i][j] = null;
                                }
                            }
                        }
                        if (getGroup(move.x, move.y, aiColor, boardAfterCapture).libertiesCount === 0) isSuicide = true;
                    } else {
                        if (getGroup(move.x, move.y, aiColor, tempBoard).libertiesCount === 0) isSuicide = true;
                    }

                    if (isSuicide || boardsAreEqual(tempBoard, previousBoard)) {
                        move.score = -1000; // Ne pas jouer de coup suicide ou ko
                        return;
                    }

                    // Defensive: Save own groups
                    if (aiDifficulty === 'hard') {
                         [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
                            const nx = move.x + dx, ny = move.y + dy;
                            if (nx >= 0 && nx < size && ny >= 0 && ny < size && board[nx][ny] === aiColor) {
                                const { group, libertiesCount } = getGroup(nx, ny, aiColor, board);
                                if (libertiesCount === 1) {
                                    move.score += 80 * group.size; // Haute priorit√© pour sauver un groupe en atari
                                }
                            }
                        });
                    }

                    // Offensive: Put opponent groups in atari
                    [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
                        const nx = move.x + dx, ny = move.y + dy;
                        if (nx >= 0 && nx < size && ny >= 0 && ny < size && board[nx][ny] === opponent) {
                            const { libertiesCount } = getGroup(nx, ny, opponent, board);
                            if (libertiesCount === 1) {
                                move.score += 40; // Mettre en atari est un bon coup
                            }
                        }
                    });
                    
                    // Positional: Play near other stones
                    [[0,1],[0,-1],[1,0],[-1,0], [1,1], [1,-1], [-1,1], [-1,-1]].forEach(([dx, dy]) => {
                        const nx = move.x + dx, ny = move.y + dy;
                        if (nx >= 0 && nx < size && ny >= 0 && ny < size) {
                           if(board[nx][ny] === aiColor) move.score += 2; // Connecter ses propres pierres
                           if(board[nx][ny] === opponent) move.score += 1; // Jouer pr√®s de l'adversaire
                        }
                    });
                    
                    move.score += Math.random(); // Ajouter un peu d'al√©atoire pour d√©partager les ex aequo
                });

                possibleMoves = possibleMoves.filter(move => move.score > -1000);
                if (possibleMoves.length === 0) return null; // Aucun coup l√©gal, l'IA doit passer

                possibleMoves.sort((a, b) => b.score - a.score);
                
                // IA: La difficult√© change le choix du coup
                if (aiDifficulty === 'easy' && Math.random() < 0.6) { // 60% de chance de jouer un coup al√©atoire
                    return possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                }
                
                return possibleMoves[0]; // Joue le meilleur coup
            };
            
            // IA: useEffect pour d√©clencher le tour de l'IA
            useEffect(() => {
                if (gameMode === 'ai' && turn === 'W' && !gameOver && !isAiThinking) {
                    setIsAiThinking(true);
                    setTimeout(() => {
                        const aiMove = findBestMoveForAI();
                        if (aiMove) {
                            playMove(aiMove.x, aiMove.y, false);
                        } else {
                            handlePass(false); // Si l'IA n'a pas de coup, elle passe
                        }
                        setIsAiThinking(false);
                    }, 1000); // D√©lai pour simuler la r√©flexion
                }
            }, [turn, gameMode, gameOver, isAiThinking]);

            const playMove = (x, y, isHumanMove = true) => {
                if (isHumanMove) {
                    if (gameMode === 'online' && turn !== playerColor) return;
                    if (gameMode === 'ai' && turn === 'W') return;
                }
                if (gameOver || !board || board[x][y]) { return; }

                let newBoard = board.map(row => [...row]);
                newBoard[x][y] = turn;
                const opponent = turn === 'B' ? 'W' : 'B';
                let totalCaptured = 0;

                [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
                    const nx = x + dx, ny = y + dy;
                    if (nx >= 0 && nx < size && ny >= 0 && ny < size && newBoard[nx][ny] === opponent) {
                        const { group, libertiesCount } = getGroup(nx, ny, opponent, newBoard);
                        if (libertiesCount === 0) {
                            group.forEach(k => {
                                const [gx, gy] = k.split(',').map(Number);
                                if (newBoard[gx][gy] !== null) { newBoard[gx][gy] = null; totalCaptured++; }
                            });
                        }
                    }
                });

                if (getGroup(x, y, turn, newBoard).libertiesCount === 0) { return; }
                if (boardsAreEqual(newBoard, previousBoard)) {
                    setKoWarning(true);
                    setTimeout(() => setKoWarning(false), 300);
                    return;
                }

                const newCaptures = { ...captures, [turn]: captures[turn] + totalCaptured };
                const newLastMove = {x, y};
                const newPreviousBoard = board.map(row => [...row]);
                const newTurn = opponent;
                
                if (gameMode === 'online') {
                    updateGameState(newBoard, newPreviousBoard, newTurn, newCaptures, newLastMove, 0);
                } else {
                    setPreviousBoard(newPreviousBoard);
                    setBoard(newBoard);
                    setCaptures(newCaptures);
                    setTurn(newTurn);
                    setLastMove(newLastMove);
                    setPassCount(0);
                }
            };

            const handlePass = (isHumanMove = true) => {
                if (isHumanMove) {
                    if (gameMode === 'online' && turn !== playerColor) return;
                    if (gameMode === 'ai' && turn === 'W') return;
                }

                if(passCount + 1 >= 2) {
                    computeFinalScore();
                } else {
                    const newTurn = turn === 'B' ? 'W' : 'B';
                    const newPassCount = passCount + 1;
                    
                    if (gameMode === 'online') {
                        updateGameState(board, null, newTurn, captures, lastMove, newPassCount);
                    } else {
                        setPassCount(newPassCount);
                        setTurn(newTurn);
                        setPreviousBoard(null);
                    }
                }
            };

            const handleResign = () => {
                const winner = turn === 'B' ? 'Blanc' : 'Noir';
                if (gameMode === 'online') {
                    endGameOnline(winner, '-', '-', null);
                } else {
                    setScoreInfo({ winner, finalB: '-', finalW: '-' });
                    setGameOver(true);
                }
            };

            const computeFinalScore = () => {
                if (!board) return;
                
                let map = Array(size).fill(null).map(() => Array(size).fill(null));
                let visited = new Set();
                let bTerr = 0, wTerr = 0;

                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size; j++) {
                        if (board[i][j] === null && !visited.has(`${i},${j}`)) {
                            const area = [], borders = new Set();
                            const stack = [[i, j]];
                            visited.add(`${i},${j}`);
                            while(stack.length > 0) {
                                const [cx, cy] = stack.pop();
                                area.push([cx, cy]);
                                [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
                                    const nx = cx + dx, ny = cy + dy;
                                    if (nx >= 0 && nx < size && ny >= 0 && ny < size) {
                                        if (board[nx][ny] === null) {
                                            if (!visited.has(`${nx},${ny}`)) {
                                                visited.add(`${nx},${ny}`);
                                                stack.push([nx, ny]);
                                            }
                                        } else borders.add(board[nx][ny]);
                                    }
                                });
                            }
                            if (borders.size === 1) {
                                const owner = borders.has('B') ? 'B' : 'W';
                                area.forEach(([ax, ay]) => {
                                    map[ax][ay] = owner;
                                    owner === 'B' ? bTerr++ : wTerr++;
                                });
                            }
                        }
                    }
                }
                const finalB = bTerr + captures.B;
                const finalW = wTerr + captures.W + KOMI;
                const winner = finalB > finalW ? 'Noir' : 'Blanc';
                
                if (gameMode === 'online') {
                    endGameOnline(winner, finalB, finalW, map);
                } else {
                    setTerritoryMap(map);
                    setScoreInfo({ finalB, finalW, winner });
                    setGameOver(true);
                }
            };

            const hoshiPoints = useMemo(() => {
                if (size === 9) return [[2, 2], [2, 6], [6, 2], [6, 6], [4, 4]];
                if (size === 13) return [[3, 3], [3, 9], [9, 3], [9, 9], [6, 6]];
                return [[3, 3], [3, 9], [3, 15], [9, 3], [9, 9], [9, 15], [15, 3], [15, 9], [15, 15]];
            }, [size]);

            if (gameMode === 'menu') {
                return (
                    <div className="flex flex-col items-center justify-center min-h-screen p-4">
                        <div className="bg-[#262421] p-8 rounded-2xl shadow-2xl max-w-md w-full">
                            <h1 className="text-4xl font-black text-center mb-2 text-zinc-600 tracking-tighter">GOMASTER</h1>
                            <p className="text-center text-zinc-500 mb-8 text-sm">Choisissez votre mode de jeu</p>
                            
                            <div className="space-y-4">
                                <button onClick={() => resetGame(size, 'local')} className="w-full bg-gradient-to-r from-blue-600 to-blue-700 py-4 rounded-xl font-bold hover:from-blue-500 hover:to-blue-600 transition-all shadow-lg transform hover:scale-105">
                                    üè† Partie Locale
                                    <p className="text-xs opacity-75 font-normal">Deux joueurs sur le m√™me appareil</p>
                                </button>
                                
                                {/* IA: Nouvelle section pour le mode IA */}
                                <div className="bg-zinc-800 p-4 rounded-xl">
                                    <div className="flex justify-between items-center mb-3">
                                        <h3 className="font-bold text-lg text-purple-300">üë§ vs ü§ñ Jouer contre l'IA</h3>
                                        <div className="flex gap-2">
                                            {['easy', 'medium', 'hard'].map(level => (
                                                <button key={level} onClick={() => setAiDifficulty(level)} className={`px-3 py-1 text-xs rounded-full font-semibold transition ${aiDifficulty === level ? 'bg-purple-500 text-white' : 'bg-zinc-700 text-zinc-300 hover:bg-zinc-600'}`}>
                                                    {level.charAt(0).toUpperCase() + level.slice(1)}
                                                </button>
                                            ))}
                                        </div>
                                    </div>
                                    <button onClick={startAiGame} className="w-full bg-gradient-to-r from-purple-600 to-indigo-700 py-3 rounded-xl font-bold hover:from-purple-500 hover:to-indigo-600 transition-all shadow-lg transform hover:scale-105">
                                        Lancer la partie IA
                                    </button>
                                </div>

                                <div className="border-t border-zinc-700 my-4"></div>

                                <button onClick={createOnlineGame} className="w-full bg-gradient-to-r from-green-600 to-green-700 py-4 rounded-xl font-bold hover:from-green-500 hover:to-green-600 transition-all shadow-lg transform hover:scale-105">
                                    üåê Cr√©er une partie en ligne
                                </button>

                                <div className="relative">
                                    <input type="text" placeholder="Code de la partie (ex: ABC123)" value={inputRoomId} onChange={(e) => setInputRoomId(e.target.value.toUpperCase())} className="w-full bg-zinc-800 py-3 px-4 rounded-lg text-center font-mono text-lg tracking-wider outline-none focus:ring-2 focus:ring-yellow-500" maxLength={6}/>
                                </div>

                                <button onClick={() => inputRoomId && joinOnlineGame(inputRoomId)} disabled={!inputRoomId} className="w-full bg-gradient-to-r from-yellow-600 to-yellow-700 py-4 rounded-xl font-bold hover:from-yellow-500 hover:to-yellow-600 transition-all shadow-lg transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none">
                                    üö™ Rejoindre une partie
                                </button>
                            </div>
                        </div>
                    </div>
                );
            }

            if (!board || !Array.isArray(board)) {
                return (
                    <div className="flex items-center justify-center min-h-screen">
                        <div className="text-center">
                            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-yellow-500 mx-auto mb-4"></div>
                            <p className="text-zinc-400">Chargement...</p>
                        </div>
                    </div>
                );
            }

            return (
                <div className="flex flex-col items-center p-4 max-w-xl mx-auto">
                    {gameMode === 'online' && (
                        <div className="w-full mb-4 bg-gradient-to-r from-purple-900 to-indigo-900 p-4 rounded-xl shadow-lg">
                            <div className="flex justify-between items-center">
                                <div>
                                    <p className="text-xs text-purple-200">Code de partie</p>
                                    <p className="text-2xl font-black tracking-widest font-mono">{roomId}</p>
                                </div>
                                <div className="text-right">
                                    <p className="text-xs text-purple-200">Vous jouez</p>
                                    <div className="flex items-center gap-2 justify-end">
                                        <p className="text-lg font-bold">{playerColor === 'B' ? 'NOIR' : 'BLANC'}</p>
                                        <div className={`w-6 h-6 rounded-full ${playerColor === 'B' ? 'stone-black' : 'stone-white'}`} />
                                    </div>
                                </div>
                            </div>
                            {!opponentConnected && (
                                <p className="text-center text-yellow-300 text-sm mt-2 pulse">
                                    ‚è≥ En attente de l'adversaire...
                                </p>
                            )}
                        </div>
                    )}

                    <div className={`flex justify-between w-full mb-6 bg-[#262421] p-4 rounded-xl shadow-2xl border-b-4 border-zinc-900 ${koWarning ? 'ko-warning' : ''}`}>
                        <div className={`flex items-center gap-3 p-2 rounded-lg ${turn === 'B' && !gameOver ? 'bg-zinc-700 ring-1 ring-zinc-500' : ''}`}>
                            <div className="w-10 h-10 stone-black rounded-full" />
                            <div><p className="font-bold text-sm">JOUEUR</p><p className="text-xs text-zinc-400">Pris: {captures.B}</p></div>
                        </div>
                        <div className="text-center">
                            <span className="text-2xl font-black text-zinc-600 tracking-tighter">GOMASTER</span>
                            {gameOver && <p className="text-green-500 font-bold text-xs animate-pulse">PARTIE TERMIN√âE</p>}
                            {koWarning && <p className="text-red-500 font-bold text-xs animate-pulse">‚ö†Ô∏è KO INTERDIT</p>}
                            {/* IA: Message pendant la r√©flexion de l'IA */}
                            {isAiThinking && <p className="text-yellow-500 font-bold text-xs pulse">ü§ñ L'IA r√©fl√©chit...</p>}
                        </div>
                        <div className={`flex items-center gap-3 p-2 rounded-lg ${turn === 'W' && !gameOver ? 'bg-zinc-700 ring-1 ring-zinc-500' : ''}`}>
                            <div className="text-right">
                                <p className="font-bold text-sm">{gameMode === 'ai' ? 'IA' : 'BLANC'}</p>
                                <p className="text-xs text-zinc-400">Pris: {captures.W}</p>
                            </div>
                            <div className="w-10 h-10 stone-white rounded-full" />
                        </div>
                    </div>

                    <div className="goban-container" style={{ width: 'min(92vw, 500px)', height: 'min(92vw, 500px)' }}>
                        {Array.from({length: size}).map((_, i) => (
                            <React.Fragment key={i}>
                                <div className="line-h" style={{ top: `${(i + 1) * cellSize}%`, left: `${cellSize}%`, right: `${cellSize}%`, height: '1.5px' }} />
                                <div className="line-v" style={{ left: `${(i + 1) * cellSize}%`, top: `${cellSize}%`, bottom: `${cellSize}%`, width: '1.5px' }} />
                            </React.Fragment>
                        ))}
                        {hoshiPoints.map(([hx, hy], i) => (
                            <div key={i} className="hoshi" style={{ left: `${(hx + 1) * cellSize}%`, top: `${(hy + 1) * cellSize}%`, width: '8px', height: '8px' }} />
                        ))}
                        
                        {board.map((row, x) => row.map((cell, y) => cell && (
                            <div key={`${x}-${y}`} className={`stone ${cell === 'B' ? 'stone-black' : 'stone-white'}`}
                                style={{ left: `${(x + 1) * cellSize}%`, top: `${(y + 1) * cellSize}%`, width: `${cellSize * 0.92}%`, height: `${cellSize * 0.92}%` }}>
                                {lastMove?.x === x && lastMove?.y === y && <div className="marker"></div>}
                            </div>
                        )))}

                        {territoryMap && board.map((row, x) => row.map((cell, y) => territoryMap[x][y] && !cell && (
                            <div key={`t-${x}-${y}`} 
                                className={`territory-marker ${territoryMap[x][y] === 'B' ? 'territory-marker-black' : 'territory-marker-white'}`}
                                style={{ left: `${(x + 1) * cellSize}%`, top: `${(y + 1) * cellSize}%` }} />
                        )))}

                        <div className="click-layer" style={{ gridTemplateColumns: `repeat(${size}, 1fr)`, gridTemplateRows: `repeat(${size}, 1fr)`, padding: `${cellSize/2}%` }}>
                            {Array.from({length: size * size}).map((_, i) => (
                                <div key={i} onClick={() => playMove(i % size, Math.floor(i / size), true)} className="w-full h-full cursor-pointer" />
                            ))}
                        </div>
                    </div>

                    {gameOver ? (
                        <div className="mt-6 p-4 bg-zinc-800 rounded-lg w-full text-center border border-green-900">
                            <h3 className="text-xl font-bold text-green-400 mb-1">{scoreInfo?.winner} gagne !</h3>
                            <p className="text-sm text-zinc-300">
                                Joueur: {scoreInfo?.finalB} | IA: {typeof scoreInfo?.finalW === 'number' ? scoreInfo.finalW.toFixed(1) : scoreInfo?.finalW} (Komi incl.)
                            </p>
                            <button onClick={() => resetGame(size, gameMode)} className="mt-4 bg-green-600 px-6 py-2 rounded-full font-bold hover:bg-green-500 transition">
                                Rejouer
                            </button>
                        </div>
                    ) : (
                        <div className="mt-6 flex gap-4 w-full">
                            <button onClick={() => handlePass(true)} disabled={(gameMode === 'online' && turn !== playerColor) || (gameMode === 'ai' && turn === 'W')} className="flex-1 bg-zinc-700 py-3 rounded-xl font-bold hover:bg-zinc-600 transition tracking-widest uppercase text-xs disabled:opacity-50 disabled:cursor-not-allowed">
                                Passe
                            </button>
                            <button onClick={handleResign} disabled={(gameMode === 'online' && turn !== playerColor) || (gameMode === 'ai' && turn === 'W')} className="flex-1 bg-red-900/30 text-red-400 py-3 rounded-xl font-bold hover:bg-red-900/50 transition tracking-widest uppercase text-xs border border-red-900/50 disabled:opacity-50 disabled:cursor-not-allowed">
                                Abandon
                            </button>
                        </div>
                    )}

                     {gameMode !== 'online' && (
                        <div className="mt-8 flex gap-2">
                            {[9, 13, 19].map(s => (
                                <button key={s} onClick={() => resetGame(s, gameMode)} className={`px-4 py-1 rounded-md text-xs font-bold ${size === s ? 'bg-yellow-600 text-black' : 'bg-zinc-800 text-zinc-500'}`}>
                                    {s}x{s}
                                </button>
                            ))}
                        </div>
                    )}

                    <button onClick={() => resetGame(size)} className="mt-4 bg-zinc-800 px-6 py-2 rounded-full text-xs font-bold hover:bg-zinc-700 transition">
                        üè† Retour au menu
                    </button>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<GoApp />);
    </script>
</body>
</html>
